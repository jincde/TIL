## heapq

리스트에서 가장 작은 값이 `index 0`으로 오도록 정렬되는 알고리즘

- 특징
  - 리스트 끝까지 오름차순으로 정렬되진 않음
  - 완전 이진 트리 기반`위에서 아래로, 왼쪽에서 오른쪽으로` **최소 힙** 자료구조
  - 즉, 루트 노드는 `가장 작은 값`

<br>

### import

```python
import heapq
```

<br>

### 생성

```python
arr = []
```

> 리스트 선언과 같다

<br>

### heapq.heappush()

```python
heapq.heappush(arr, 100)
heapq.heappush(arr, 20)
heapq.heappush(arr, 30)
heapq.heappush(arr, 40)

print(arr) # [20, 100, 30, 40]
```

> 가장 작은 값이 arr[0]에 왔다
>
> arr[1]이후의 값은 다를 수 있다

<br>

### heapq.heappop()

```python
print(heapq.heappop(arr))  # [20, 100, 30, 40]
print(heap_list)  # [30, 100, 40] 
a = heapq.heappop(arr)
print(a)  # 30
```

> arr[0]의 값(최소 값)이 삭제되면서 반환
>
> 삭제된 후 arr[0]은 최소 값으로 다시 정렬된다

<br>

### heapq.heapify()

```python
arr = [9, 8, 7, 6, 5, 4, 1, 2, 5]
heapq.heapify(arr)
print(arr)  # [1, 2, 4, 5, 5, 7, 9, 6, 8]
```

> 기존 리스트를 heapq으로 변환

<br>

### 응용

```python
numbers = [1,5,9,3,7,6,4,2,8]
max_ = []
for number in numbers:
    heapq.heappush(max_, (-number, number))

while max_list:
    print(heapq.heappop(max_)[1])
```

> 최대값 구하기
>
> 우선순위, -를 붙이면 가장 큰 값이 가장 작아진다.
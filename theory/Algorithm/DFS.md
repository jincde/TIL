# 그래프탐색 알고리즘

### 1. 그래프 탐색 알고리즘이란?

- 시작 정점에서 간선을 타고 이동할 수 있는 모든 정점을 찾는 알고리즘

- `DFS`(깊이 우선), `BFS`(너비우선) 탐색이 있다.

  - DFS : 그래프의 깊이를 우선으로 탐색하기 위해 `스택`을 활용
  - BFS : 그래프 너비를 우선으로 탐색하기 위해 `큐`를 활용

- 스택 + 그래프 + 큐

  ```
      1
     / \
    2   3
   / \   \
  4   5   6
  
  DFS : 1 2 4 5 3 6
  BFS : 1 2 3 4 5 6
  ```

  

### 2. DFS

- 시작 정점부터 갈 수 있는 하위 정점까지 가장 깊게 탐색

- 더 이상 갈 곳이 없다면 마지막 갈림길로 돌아와 다른 정점을 탐색

- 미로 탈출

  - 어느 한 쪽 길로 가장 깊게 들어갔다가 막히면 다시 돌아와 다른 길을 탐색

- 모든 정점을 방문할 때 유리, `경우의 수` `순열과 조합`문제에서 주로 사용

  #### 2-1 동작 과정

  - 먼저 탐색을 진행할 그래프가 필요

  - 인접 행렬 또는 인접 리스트 방식으로 표현

  - 각 정점을 방문했는지 여부 판별할 방문 리스트가 필요

    ```python
    visited = [False] * n # n은 정점 개수
    '''
    정점 0 1 2 3 4 5 6
    vst 0 0 0 0 0 0 0
    '''
    ```

    ```python
    # 1. 인접 리스트 표현
        0
       / \
      1   2
     / \   \
    3   4   5
         \
          6
    
    graph = [
    [1, 2],
    [0, 3, 4],
    [0, 4, 5],
    [1],
    [1, 2, 6],
    [2],
    [4]
    ]
    ```

    ```python
    # 2. 반복문을 이용한 DFS
    visited = [False] * n # 방문 처리 리스트
    
    def dfs(start):
      stack = [start] # 돌아갈 곳을 기록
      visited[start] = True # 시작 정점 방문 처리
      
      while stack: # 돌아갈 곳이 없을때까지 반복
        cur = stack.pop() # 현재 방문 정점(LIFO)
        
        for adj in graph[cur]:
          if not visited[adj]: # 아직 방문하지 않았다면
            visited[adj] = True # 방문 처리
            stack.append(adj) # 스택에 추가
    ```

    
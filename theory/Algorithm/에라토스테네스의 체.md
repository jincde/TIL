## 문제 핵심

A부터 B까지 숫자가 있을 때, 범위 안 소수 중에서 D값이 포함된 소수의 개수를 출력

1 ≤ D ≤ 9, 

1 ≤ A ≤ B ≤ `10 ** 6`



## 소수

소수는 자신보다 작은 2개의 자연수를 곱해 만들 수 없는 1보다 큰 자연수

> 1과, 자기 자신 외에 약수가 존재하지 않음 ex) 2, 3, 5, 7, 11...



## 에라토스테네스의 체

1. 구하고자 하는 소수 범위만큼 1차원 리스트 생성

2. 2부터 시작, 리스트를 끝까지 탐색하며 배수에 해당하는 수를 삭제

   > 0과 1은 소수가 아니기 때문

3. 처음으로 선택된 숫자는 지우지 않는다

   > 2를 선택하면 4부터 삭제



## 1부터 25까지 소수 판별

1. 주어진 범위까지 리스트 생성, 1은 소수가 아니기 때문에 삭제하고 2부터 시작

| 1    | 2    | 3    | 4    | 5    |
| ---- | ---- | ---- | ---- | ---- |
| 6    | 7    | 8    | 9    | 10   |
| 11   | 12   | 13   | 14   | 15   |
| 16   | 17   | 18   | 19   | 20   |
| 21   | 22   | 23   | 24   | 25   |

> 보기 편하게 2차원리스트처럼 표현



2. `2`부터 시작

|      | 2    | 3    |      | 5    |
| ---- | ---- | ---- | ---- | ---- |
|      | 7    |      | 9    |      |
| 11   |      | 13   |      | 15   |
|      | 17   |      | 19   |      |
| 21   |      | 23   |      | 25   |

> 현재 선택한 수는 2, 
>
> 2를 제외한 2의 배수 삭제



3. 다음 지워지지 않은 수를 선택`3`

|      | 2    | 3    |      | 5    |
| ---- | ---- | ---- | ---- | ---- |
|      | 7    |      |      |      |
| 11   |      | 13   |      |      |
|      | 17   |      | 19   |      |
|      |      | 23   |      | 25   |

> 현재 선택한 수는 3, 
>
> 3을 제외한 3의 배수 삭제



4. 다음 지워지지 않은 수를 선택`5`

|      | 2    | 3    |      | 5    |
| ---- | ---- | ---- | ---- | ---- |
|      | 7    |      |      |      |
| 11   |      | 13   |      |      |
|      | 17   |      | 19   |      |
|      |      | 23   |      |      |



5. 2번부터 4번까지의 과정을 리스트 끝까지 반복

> 최종 지워지지 않은 수를 모두 출력 2, 3, 5, 7, 11, 13, 17, 19, 23



## 구현

```python
# 에라토스테네스의 체
# 인덱스를 이용

N = 10 ** 6
T = int(input()) # 테스트케이스 개수 변수
arr = [True]*(N+1) # 0부터 인덱스가 시작이기 때문 N+1
arr[0] = False # 0과 1은 소수가 아니기 때문에 미리 지정
arr[1] = False

def isPrime():
  for i in range(N+1):
    if arr[i] == True: # 인덱스i번째가 True
      for j in range(i*2, N+1, i): # i가 2면, 4부터 시작, +2 
        arr[j] = False # 자기자신 숫자를 제외한 배수들은 지워준다

isPrime() # 함수 호출

for tc in range(1, T+1):
  D, A, B = map(int, input().split())
  result = [] # 스페셜 소수를 담을 리스트
  
  for i in range(A, B+1):
    if str(D) in str(i) and arr[i] == True: # 스페셜 숫자가 포함되어 있고, arr[i]가 소수이면
      result.append(i)
      
  print(f'#{tc} {len(result)}')
```

<br>

## 시간복잡도

이중 for문을 이용하기 때문에 시간복잡도가 O(N의 제곱)정도로 볼 수 있으나, 일반적으로 O(N log N) 

배수를 삭제하는 연산으로 실제 구현에서 바깥 for문을 생략하는 경우가 많이 발생하기 때문.







```python
# 에라토스테네스의 체
import math

T = int(input())

for tc in range(1, T+1):
    D, A, B = map(int, input().split())
    arr = [0] * (B+1)
    isprime = []
    cnt = 0
  
for i in range(2, B+1):
    arr[i] = i

for i in range(2, int(math.sqrt(B)) + 1):
    if arr[i] == 0:
        continue
    for j in range(i + i, B+1, i):
        arr[j] = 0

for i in range(A, B+1):
    if arr[i] != 0:
        isprime.append(i)

for k in isprime:
    if str(D) in str(k):
        cnt += 1
print(f'#{tc} {cnt}')

# 반복 불가
# 함수화하자
```






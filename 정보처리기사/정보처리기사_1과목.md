# 1과목

## 1-1 소프트웨어 공학

- SW위기를 극복, 품질높은 SW를 개발

- 무어의 법칙

  - 반도체 집적회로의 성능이 24개월마다 2배로 증가

- 암달의 법칙

  - 프로세스 수를 늘려도 속도를 개선하는데 한계가 있다

- 브룩스의 법칙

  - 지체되는 소프트웨어 개발 프로젝트에 인력을 더하는 것은 오히려 늦춘다

  

- 3R
  - 역공학 : 기존 시스템을 CASE도구를 이용해 문서로 추출
  - 재공학 : 기존 시스템의 기능이나 성능을 업그레이드
  - 재사용 : SW전체 또는 일부분을 다시 사용
    - 합성 중심 - 끼워 맞추기
    - 생성 중심 - 추상화



## 1-2 SW 개발 방법론

- 구조적 방법론 - 하향식
  - 절차지향
  - 구조적 방법론
  - 데이터 흐름도, 자료사전, 상태전이도, 소단위 명세서
- 객체지향 방법론 - 상향식
  - 현실세게의 개체를 속성과 메소드 형태로 표현 
  - 캡슐화, 정보은닉, 상속, 다형성, 추상화
- 정보공학 방법론
  - 회사에서 씀
- CBD
  - 재사용 가능한 컴포넌트의 개발 또는 조합
- 애자일
  - XP, Scrum, FDD, Crystal, LEAN



- SW개발 모델
  - 폭포수
  - 프로토타이핑
  - 나선형
  - RAD
  - V
  - 4세대 기법



## 1-3 프로젝트 관리

- 프로젝트 핵심관리 대상

  - 사물, 문제, 프로세스

  

- PMBOK

  - 착수 계획 실행 통제 종료



- 개발 비용 산정
  - 하향식
    - 전문가 기법: 전문가의 경험
    - 델파이 기법: 전문가들이 모여 회의를 통해
  - 상향식
    - LOC (낙관치 + (4 * 중간치) + 비관치) / 6
    - M/M
  - 수학적
    - COCOMO 5-30-30 o s e
    - PUTNAM - rayleigh-norden - slim
    - FP(기능점수) ESTIMACS도구



- 개발 일정 산정
  - 작업분해 WBS
  - CPM네트워크 작성 (PERT/CPM)
  - 최소 소요 기간을 구함(임계경로)
  - 간트차트로 표현



## 1-4 요구사항 분석

- 현행 시스템 파악

  - 운영체제

  - 네트워크

  - DBMS

  - MIDDLEWARE

    - RPC, MOM, ORB, DB접속 미들웨어, TP monitor, WAS, ESB

    

- 플랫폼의 유형

  - 싱글 사이드
  - 투 사이드
  - 멀티 사이드



- 요구공학
  - 고객 요구사항을 도출하고 관리하는 기법
- **도분명확** 도출 분석 명세 확인
- 요구사항 확인
  - 분석가가 요구사항을 이해했는지 **확인(Validation)**
  - 요구사항 문서가 일관성 있고 완전한지 **검증(Verification)**



- 요구사항 분류
  - 기능적 요구사항 
  - 비기능적 요구사항 : 보안, 성능, 품질, 안전성



- 요구사항 분석도구
  - CASE 
    - 상위 : 계획과 분석, 설계 단계 지원
    - 하위 : 코드 작성, 테스트, 문서화 과정 지원
    - 통합 : SDLC에 포함되는 전체 과정을 지원
  - HIPO
    - 하향식 소프트웨어 개발을 위한 문서화 도구 (절차적)
    - 가시적, 총체적, 세부적 도표



- 요구사항 모델링
  - 이해하기 쉽게 간단한 모델로 표현
  - 자료 흐름도
  - 자료 사전
    - 이름 + 주소 + [남|여] + {대여목록}
  - 소단위 명세서
  - ER다이어그램
  - 상태전이도



- 객체지향 분석 모델
  - 럼바우 방법
    - 객체 모델링 : 객체 다이어그램
    - 동적 모델링 : 상태 다이어그램
    - 기능 모델링 : 자료 흐름도
  - Booch 방법
    - 미시적 - 거시적 개발 프로세스를 모두 사용
  - Jacobson
    - 유스케이스 사용
  - Coad-Yourdon
    - ER다이어그램 이용해 구성
  - Wirfs-Brock
    - 분석과 설계 구분 없음





## 1-5 소프트웨어 설계

- 요구사항 명세서를 참조해 구체적인 설계서를 작성하는 단계



- 상위 설계 : 아키텍처, 데이터, 인터페이스 정의, 사용자 인터페이스
- 하위 설계 : 모듈, 자료구조, 알고리즘



- 분할과 정복
- 추상화 : 과정, 데이터, 제어 추상화
- 단계적 분해
- 모듈화
- 정보은닉





## 1-6 설계 모델링

- 구조 모델링
  - UML 정적 다이어그램
- 행위 모델링
  - UML 동적 다이어그램



- 협약에 의한 설계
  - 선행, 결과, 불변 조건





## 1-7 소프트웨어 아키텍처

- 소프트웨어 골격이 되는 기본 구조

- 간략성, 추상화, 가시성, 관점 모형, 의사소통수단



- 4+1 뷰
  - 논구배프유
- 아키텍처 패턴
  - 계층화, 마스터-슬레이브, 클라-서버, 파이프-필터, 브로커, 피투피, 이벤트-버스, MVC, 블랙보드, 인터프리터



## 1-8 UML

- 설계를 표현하기 위해 사용하는 표기법
- 가구명문 - 가시화, 구축, 명세화, 문서화 언어



- 구성요소 - 사물, 관계, 다이어그램
- 사물
  - 구조, 행동, 그룹, 주해
- 관계
  - 연관, 집합, 포함, **일반화, 실체화**, 의존
- 다이어그램
  - 구조 다이어그램
    - 클래스, 객체, 컴포넌트, 배치, 복합체, 패키지
  - 행위 다이어그램
    - 유스케이스, 시퀀스, 커뮤니케이션, 상호작용, 활동, 상태, 타이밍





## 1-9 UI

- 컴퓨터와 사용자가 서로 상호작용을 할 수 있도록 연결해주는 매개체
- UX : 직/간접적으로 이용해 경험한 모든 것
- UI유형 : CLI, GUI, AUI, NUI



- 요구사항 구분
  - 기능적, 비기능적 요구사항
- UI 설계 원칙
  - 직관성 : 누구나 쉽게 이해
  - 유효성 : 사용자의 목적을 정확하게 달성
  - 학습성 : 누구나 쉽게 학습
  - 유연성 : 오류를 최소화, 요구사항을 최대한 수용



- UI 설계 도구
  - 와이어프레임 - 기획자 디자이너
  - 스토리보드 - 다 봄
  - 프로토타입
  - 목업
  - 유스케이스





## 1-10 감성공학

- 인간의 심상을 구체적 물리적 설계 요소로 번역해 실현
- 감각적, 기능적, 문화적





## 1-11 화면 레이아웃

- 특정 공간에 여러 구성 요소를 보기 좋게 효과적으로 배치하는 작업
  - HTML5 : 기본구조 담당(시맨틱)
  - CSS : 디자인적 요소를 분리해서 정의(반응형 웹)
  - Javascript : React, Vue.js, AngularJS, AJAX

​       

- UI 관련 용어
  - 웹 표준 : 가이드
  - 웹 접근성 : 누구나 동일한 페이지에 접근
  - 웹 호환성 : 환경이 다른 경우에도 동등한 서비스를 제공
  - 반응형 웹 : 화면 크기에 맞춰 하나의 사이트를 보여준다
  - 인포그래픽 : 정보와 그래픽의 합성어, 복잡한 정보를 쉽고 빠르게 전달
  - 브랜드 아이덴티티 : 사용자에게 전달하고자 하는 특정 브랜드의 가치와 의미를 반영한 표상
  - 네비게이션 : 하이퍼링크를 따라 웹 공간의 정보를  요청하고 받아오는 웹 브라우징을 의미
  - 아코디언 : 원하는 정보만 선택적으로 볼 수 있게 접을 수 있는 내용 패널
  - 플레이스 홀더 : 입력필드에 제공되는 텍스트 도움말
  - 필터링 : 원하지 않는 데이터 차단
  - 입력폼 : 다양한 입력 필드로 구성, 웹 서버로 전송할 정보를 입력
  - 입력필드 : 사용자가 정보를 입력하거나 선택하는데 이용
  - 썸네일 : 커다란 이미지를 축소해 제공하는 이미지
  - 레이블 : 입력폼을 구성하는 다양한 입력 필드를 식별하기 위해 사용
  - 대체 텍스트 : 콘텐츠를 대신하기 위해 제공되는 텍스트
  - 초점 : 웹 페이지에서 사용자가 선택한 해당 요소에 있을 때



## 1-12 개발 환경 구축

- 서버 환경 구축
  - 웹 서버 : Apache Web Server, ngix, GWS
  - WAS : Web Logic, Web spere, Jeus, Tomcat
  - DMBS : Oracle, MySQL, MS-SQL
  - 파일서버
  - 로드 밸런서 : Random, Least Loaded, Round robin
  - CDN : 분산되어 있는 데이터 저장 서버



- 시스템 아키텍처 고려사항
  - 확장성, 성능, 응답 시간, 처리량, 접근성, 일관성



- 개발 소프트웨어 환경
  - 운영체제
  - JVM
  - Web Server
  - WAS
  - DBMS



- IDE 도구
  - IDE도구의 기능
    - 텍스트 에디터, 컴파일, 디버거, 배포
  - 적정성, 효율성, 이식성, 친밀성, 범용성



- 협업 도구
  - 하나의 프로젝트를 여러 사용자가 동시에 수행할 수 있도록 돕는 SW



- 형상 관리 도구
  - 발생하는 변경사항을 통제하기 위한 관리 방법
  - 변경 관리 : 소스의 변경 상황을 관리
  - 버전 관리 : 변경을 관리하기 위한 효과적인 방법
  - 형상 관리 : 변경 관리와 버전 관리가 포함되고, 프로젝트 진행상황, 빌드와 릴리즈까지 모두 관리할 수 있는 통합 시스템



- 형상 관리 절차
  - 형상 식별 - 통제(CCB의 승인) - 감사 - 기록



- 버전 관리 도구
  - 공유 폴더 방식(RCS, SCCS)
  - 클라이언트/서버 방식(CVS, SVN)
  - 분산 저장소 방식(Git, Betkeeper)



- 빌드 도구
  - 소스코드 파일들을 컴퓨터에서 실행할 수 있는 SW로 변환하는 과정
  - 빌드 자동화 도구 : Make, Ant, Maven, **Jenkins, Gradle**





## 1-13 개발 프레임워크

- 프레임워크 : SW개발에 공통적으로 사용되는 구성 요소와 아키텍처를 일반화해 손쉽게 구현할 수 있도록 기능들을 제공하는 반제품 형태의 SW
  - 특징 : 모듈화, 재사용성, 확장성, 제어의 역흐름

- 라이브러리 : 빈번하게 사용되는 사전 컴파일된 루틴 또는 리소스를 모아둔 것
- API : 소프트웨어 인터페이스, 다른 종류의 SW에 서비스를 제공



## 1-14 단위모듈 구현

- 효과적인 모듈화
  - 결합도를 줄이고, 응집도를 높여 모듈의 독립성을 높임
  - FAN-OUT 최소화, FAN-IN 증가

- 작성 원칙
  - 정확성, 명확성, 완전성, 일관성, 추적성



- 결합도(Coupling)
  - 어떤 모듈이 다른 모듈에 의존하는 정도
  - 자료 < 스탬프 < 제어 < 외부 < 공용 < 내용 (클수록 bad)



- 응집도(Cohesion)
  - 모듈 내부 구성요소 간 연관 정도
  - 우연적 < 논리적 < 시간적 < 절차적 < 통신적 < 순차적 < 기능적 (클수록 good)



- 공통 모듈 구현
  - Annotation : 코드에 주석처럼 달아 특수한 의미를 부여
    - 컴파일 또는 런타임에 해석된다



## 1-15 서버프로그램 구현

- MVC모델 계층
  - 프리젠테이션 계층 - View
  - 제어 계층 - Controller
  - 비즈니스 로직 계층 - Controller
  - 퍼시스턴스 계층 - Model 데이터를 주고받음
  - 도메인 모델 계층 - Model



- DBMS 접속 기술
  - 프로그램에서 DB에 접근해 DML을 사용가능하게 하는 기술
  - 소켓 통신, Vender API, JDBC, ODBC



- ORM 프레임워크
- 객체와 관계형 데이터베이스의 데이터를 매핑해주는 것
  - DB를 쉽게 사용할 수 있게
- 매핑 기술
  - SQL Mapper : iBatis, Mybatis, jdbc템플릿 등
    - Query 사용
  - OR Mappint(=ORM) : JPA, Hibernate
    - Query 사용 X



- 시큐어코딩
  - OWASP
  - 시큐어코딩 가이드 : 입력 데이터 검증 표현, 보안기능, 시간 및 상태, 에러처리, 코드오류, 캡슐화, API 오용



## 1-16 배치 프로그램

- 데이터를 일괄적으로 모아 처리하는 대량의 작업을 처리
- 필수 요소
  - 대용량 데이터, 자동화, 견고함, 안정성, 성능



- 스케줄 관리

  - 크론탭 : UNIX, LINUX계열 사용

    `분 시 일 월 요일 명령어` 
    
    

## 1-17 인터페이스

- 서로 다른 시스템, 장치 사이에서 정보나 신호를 주고 받을 수 있도록 도움을 주는 시스템
- 송신, 중계, 수신 시스템으로 구성



- 연계 시스템 분류와 데이터 식별
  - 송수신 데이터 식별
    - 전문 공통부, 개별부, 종료부로 구성



- 인터페이스 설계서
  - 목록 : 참여하는 송수신 시스템의 정보, 방식, 유형 등에 대한 정보
  - 정의서 : 데이터 저장소와 속성등의 상세 내역을 포함



## 1-18 인터페이스 기능 구현

- 내외부 모듈 연계 방식
  - EAI : 기업에서 운영하는 서로 다른 플랫폼 간의 정보 전달, 연계, 통합을 가능하게 해주는 솔루션
    - 유형 : Point to Point, Hub & Spoke, Message bus, Hybrid
  - ESB : 웹 서비스 중심, 버스를 통해 이 기종 어플리케이션을 유연하게 통합
  - FEP : 메인프레임에서 통신 과부하를 경감시키기 위해 전처리 작업을 하는 과정



- 인터페이스 연계 기술
  - DB Link : DB에 제공하는 DB link 객체를 이용
  - DB Connection : 수신 WAS에서 송신 DB로 연결하는 `DB 커넥션 풀`을 생성, 연계 프로그램에서 해당 커넥션 풀 이름을 사용
  - JDBC
  - API / OpenAPI
  - Web Service
    - WSDL, UDDI, SOAP 프로토콜을 이용해 연계
  - Hyper Link
    - 웹 어플리케이션에서 하이퍼링크 이용
  - Socket : 직접 연결



- 인터페이스 전송 데이터

  - JSON : `키-값 쌍`으로 이뤄짐, 구조화된 데이터를 표현하기 위한 문자 기반의 표준 포맷
  - XML : 웹에서 구조화한 문서를 표현하고 전송하도록 설계한 마크업 언어
  - CSV : 몇 가지 필드를 쉼표로 구분한 텍스트 데이터
  - YAML : 사람이 쉽게 읽을 수 있는 데이터 직렬화 양식

  

- 인터페이스 구현
  - AJAX : 자바스크립트를 이용해 서버와 브라우저가 `비동기 방식`으로 통신
  - 비동기 방식 : 웹 페이지를 리로드하지 않고 데이터를 불러오는 방식
  - SOAP : HTTP, HTTPS, SMTP등을 통해 XML 기반의 메세지를 네트워크 상에서 교환하는 프로토콜
    - WSDL, UDDI, SOAP으로 구성
  - REST : HTTP URI를 통해 자원을 명시, Method(POST, GET, PUT, DELETE)를 통해 해당 자원에 대한 CRUD 연산을 적용
    - 자원, 행위, 표현으로 구성
  - RESTful



- 인터페이스 보안
  - 네트워크 영역 : IPSec, SSL, S-HTTP
  - App 영역 : 시큐어코딩 가이드
  - DB 영역 : 민감 데이터 암호화, 익명화



## 1-19 인터페이스 검증

- 인터페이스 구현 검증 도구
  - xUnit : 다양한 언어를 지원하는 단위 테스트 프레임워크
  - STAF : 서비스 호출 및 컴포넌트 재사용
  - FitNesse : 웹 기반 테스트케이스 설계
  - NTAF : FitNesse + STAF 장점을 통합
  - Selenium : 다양한 브라우저, 웹 어플리케이션 테스트 프레임워크
  - Watir : Ruby를 사용하는 테스트 프레임워크



- 인터페이스 구현 감시 도구
  - APM을 사용해 동작 상태 감시
  - DB, 웹 어플리케이션의 다양한 정보를 조회하고 분석화해 시각화
  - Scouter, Jennifer



## 1-20 객체지향 설계

- 현실 세계의 모든 대상을 객체로 나누고, Method와 속성을 정의해 설계하는 방법

- 구성요소
  - 클래스, 객체, 속성, 메소드, 메세지
- 특징
  - 캡슐화, 정보은닉, 상속, 다형성, 추상화
- 설계원칙(SOLID)
  - SRP : 단일책임 : 한 클래스는 하나의 책임
  - OCP : 개방폐쇄 : 확장에는 열려있고, 수정에는 닫혀있다
  - LSP : 리스코프 치환 : 하위 클래스는 언제나 상위 클래스를 대체
  - ISP : 인터페이스 분리 : 사용하지 않는 인터페이스는 구현하지 않는다 
  - DIP : 의존성 역전 : 변화가 거의 없는 것에 의존



- 디자인 패턴
  - GoF 디자인 패턴
    - 생성 패턴 : 추상팩토리, 빌더, 팩토리 메소드, 프로토타입, 싱글턴
    - 구조 패턴 : 어댑터, 브릿지, 컴포지트, 데코레이터, 퍼싸드, 플라이웨이트, 프록시
    - 행위 패턴



## 1-21 소프트웨어 테스트

- 사용자가 요구하는 기능의 동작과 성능을 만족하기 위해 결함을 찾아내는 활동
  - 결함집중(파레토) : 20% 핵심 모듈에서 80% 오류가 발생
  - 살충제 패러독스 : 같은 테스트 케이스로 테스트를 하면 새로운 오류를 발견할 수 없다
  - 오류-부재의 궤변 : 요구사항을 만족하지 못하면, 오류가 없는 프로그램이라도 품질이 좋다고 볼 수 없다

- 테스트 케이스
  - 입력 값, 테스트 조건, 기대 결과



- 테스트 오라클
  - 테스트 결과가 참인지 판단하기 위해 사전에 정의된 참 값을 입력해 비교하는 기법
    - 참 오라클 : 전부 수행
    - 샘플링 오라클 : 일부 수행
    - 휴리스틱 오라클 : 샘플링 후 추정
    - 일관성 검사 오라클 : 변경 시 수행 전 후 결과가 동일한지 확인



- 테스트 레벨
  - 단위 테스트 : `정적 동적 테스트` : 모듈검증
  - 통합 테스트 : `상향 하향 빅뱅 백본 테스트` : 인터페이스 검증
  - 시스템 테스트 : `기능 비기능 테스트` : 요구 분석 검증
  - 인수 테스트 : `알파 베타 테스트`



- 테스트 기법
  - 프로그램을 실행? 동적 테스트 : 정적테스트
  - 테스트 기법에 따라 화이트박스 : 블랙박스



- 기초경로 검사
  - McCaber 제안
  - 계산식 : 라인 - 노드 + 2



- 테스트에 대한 시각
  - 검증(Verification)
    - 개발과정을 테스트
    - 올바르게 만들어지고 있는지 검증
  - 확인(Validation)
    - 완성된 결과를 테스트
    - 사용자 요구사항을 만족하는지 확인



- 테스트 목적
  - 회복 테스트
  - 안전 테스트
  - 강도 테스트
  - 성능 테스트
  - 구조 테스트
  - 회귀 테스트
  - 병행 테스트



- 테스트 조율
  - 명세 기반
    - 주어진 명세를 빠짐없이 테스트 케이스로 구현하고 있는지 확인
  - 구조 기반
    - 내부 논리 흐름에 따라 테스트 케이스를 작성하고 있는지 확인
  - 경험 기반
    - 유사 평가에서 테스터의 경험을 토대로 한, 직관과 기술 능력을 기반으로 수행



- 테스트 커버리지
  - 테스트를 얼마나 수행했는지 측정
  - 유형
    - 기능 기반
    - 라인
    - 코드



## 1-22 어플리케이션 통합 테스트

- 결함관리 도구
  - 결함을 추적하고 관리할 수 있게 해주는 도구
- 결함 추이 분석
  - 결함 분포
  - 결함 추세
  - 결함 에이징



- 테스트 자동화 도구
  - 반복적인 테스트 작업을 스크립트 형태로 구현
    - 정적 분석
    - 테스트 실행
    - 성능 테스트
    - 테스트 통제
- 테스트 장치(하네스)
  - 테스트 케이스 : 입력 값, 실행 조건, 기대 결과
  - 테스트 슈트 : 테스트 케이스의 집합
  - 테스트 스크립트 : 자동화 테스트 실행 절차에 대한 명세
  - 목 오브젝트 : 행위를 조건부로 입력해 두면, 예정된 행위를 수행하는 객체
  - 테스트 스텁 : 하향식 테스트에 이용
  - 테스트 드라이버 : 상향식 테스트에 이용



- 통합 테스트
  - 모듈 간의 인터페이스 관련 결함을 찾아내기 위한 체계적 기법



## 1-23 어플리케이션 성능 개선

- 데이터베이스 관련 성능 저하
  - 데이터베이스 락
  - 불필요한 패치 (많이 로드)
  - 연결 누수
- 내부 로직으로 인한 성능 저하
- 외부 호출로 인한 성능 저하



- 어플리케이션 성능 분석 지표
  - 처리량(Throughput)
  - 응답 시간(Response Time)
  - 결과 시간(Turn Arount Time)
  - 자원 사용률(Resource Usage)



- 성능 분석 도구
  - JMeter
    - HTTP, FTP등 다양한 프로토콜을 지원하는 부하테스트 도구
  - LoadUI
    - 서버 모니터링, 드래그 앤 드랍 사용자 편리성이 강화된 도구
  - OpenSTA
    - HTTP(80포트), HTTPS(443포트)



- 모니터링 도구
  - Scouter
    - 단일 뷰 통합/실시간 모니터링
  - NMon
    - 리눅스 서버 자원에 대한 모니터링 도구
  - Zabbix
    - 웹 기반 서버, 서비스 어플리케이션 모니터링 도구
  - Jennifer
    - 어플리케이션에서 서버로 유입되는 트랜잭션 수량, 처리시간, 응답시간, 자원 활용률 등을 모니터링



- 정형 기술 검토회의(FTR)
  - 엔지니어가 수행하는 SW품질보증 활동
  - 목적
    - 산출물 요구사항 일치여부
    - 소프트웨어가 미리 정한 기준에 따라 표현 되었는지 확인
    - SW표현에 대한 기능, 논리적 오류
    - 프로젝트를 관리하기 쉽게



- 소스코드 품질 분석
  - 동료 검토(Peer Review)
    - 2~3명이 진행하는 리뷰의 형태
  - 워크스루(Walkthrough)
    - 검토자료를 회의 전에 배포해 사전검토 후 짧은 시간 동안 회의를 진행
  - 인스펙션(Inspection)
    - 공식적 검사 회의
    - 전문가 검사 리뷰 기법



- 소스코드 품질 분석 도구
  - 정적
    - PMD : 주로 Java에서 사용, Javascrip등의 언어도 지원
    - checkstyle : Java코드에 대한 소스 코드 표준 준수 검사
    - SonarQube : 중복코드, 복잡도 설계 등을 분석
    - cppcheck : C, C++코드에 대한 메모리 누수 등 검사
    - ccm : 다양한 언어의 코드 복잡도 분석 도구
    - cobertura : Java언어의 소스 코드 복잡도 분석
  - 동적
    - Avalanche : 프로그램에 대한 결함 및 취약점 분석
    - Valgrind : 프로그램 내 존재하는 메모리 및 스레드 결함 등 분석



- 어플리케이션 성능 개선
  - 코드 최적화
    - 주어진 코드에 대한 같은 작업을 수행 하면서, 실행 기간을 줄이거나 메모리를 줄이는 것
  - 코드 스멜
    - 스파게티 코드 : 소스 코드가 복잡하게 얽힌 모습
    - 외계인 코드 : 아주 오래되거나 참고 문서 또는 개발자가 없어 유지보수가 어려운 코드



- 리팩토링
  - 외부 동작을 바꾸지 않으면서 내부 구조를 개선하는 방법
  - 클린코드
    - 가독성
    - 단순성
    - 의존성 배재
    - 중복성 최소화
    - 추상화



## 1-24 소프트웨어 유지보수

- 개발 완료 시점부터 폐기될 때까지, 지속적으로 수행



- 유지보수 구분
  - 수정 보수 : 오류를 찾아 수정
  - 적응 보수 : 환경 변화에 맞추기 위해 수행
  - 향상 보수 : 기존 기능과 다른 기능을 추가, 개선
  - 예방 보수 : 신뢰성을 보장, 선제적으로 하는 보수
- 레거시 시스템 : 낡은 기술이나, 소프트웨어



## 1-25 국제 표준 제품 품질

- 제품 품질
  - ISO/IEC `9126` `기신사효유이`
    - 기능성, 신뢰성, 사용성, 효율성, 유지보수성, 이식성
  - ISO/IEC`14598` `재공객반`
    - 재현성, 공정성, 객관성, 반복성
  - ISO/IEC`12119` `+테스트`
    - 패키지 SW 품질 요구사항 및 테스트
  - ISO/IEC`25000`
    - 9126, 14598, 12119, 15228을 5개 영역 중심으로 통합



- 프로세스 품질
  - ISO/IEC `12207`
    - 기본 생명주기
    - 지원 생명주기
    - 조직 생명주기
  - ISO/IEC `15504` `SPICE`
    - 총 6단계
      - 0. 불안정 단계
        1. 수행 단계
        2. 관리 단계
        3. 확립 단계
        4. 예측 단계
        5. 최적화 단계
  - CMM
    - 총 5단계
      - 1. 초기 단계
        2. 반복 단계
        3. 정의 단계
        4. 관리 단계
        5. 최적화 단계
  - CMMi
    - 총 5단계
      - 1. 초기 단계
        2. 관리 단계
        3. 정의 단계
        4. 정량적 관리 단계
        5. 최적화 단계



## 1-26 제품 소프트웨어 패키징

- 어플리케이션 패키징
  - 개발이 완료된 소프트웨어를 고객에게 전달하기 위한 형태로 패키징, 매뉴얼을 작성
  - 1. 기능 식별
    2. 모듈화
    3. 빌드 진행
    4. 사용자 환경분석
    5. 패키징 적용 시험
    6. 패키징 변경 개선
- 릴리즈 노트
  - 소프트웨어 제품과 함께 배포되는 문서
- DRM
  - 디지털 콘텐츠의 불법적인 사용을 제한, 저작권 소유자의 의도에 따라 제어하는 기술
    - 콘텐츠 제공자 : 영화 제작자
    - 콘텐츠 분배자 : 영화관
    - 클리어링 하우스 : 영화관 본사
    - 콘텐츠 소비자 : 관람객
  - 콘텐츠 식별 체계
    - 고유 식별 번호를 부여(DOI, URI)
  - 메타데이터
    - 콘텐츠에 대한 구조화된 데이터
  - 권리표현기술
    - 콘텐츠에 대한 규칙 설정
    - XrML
  - 권리표현 종류
    - Render Permission : 이용 권리
    - Transport Permission : 권리 교환이 가능
    - Derivative Permission : 콘텐츠 추출 변형이 가능
  - 저작권 보호기술
    - 암호화 기술
    - 위변조 방지
    - 워터마킹
      - 워터마킹 : 불법 **복제** 방지, 저작권 정보 삽입
      - 핑거프린팅 : 불법 **유통** 방지, 저작권 정보 + 구매자 정보 삽입
  - 구성 요소
    - 암호화, 암호화 파일 생성
    - 키관리
    - 식별기술(URI, DOI)
    - 저작권 표현
    - 정책 관리
    - 크랙 방지
    - 인증



## 1-27 제품 소프트웨어 매뉴얼 작성

- 설치, 사용자 매뉴얼
